# ğŸ“š Garbage Collector e Escopo Local em Java

## ğŸ¯ O que Ã© Garbage Collector?

O **Garbage Collector (GC)** Ã© o mecanismo do Java responsÃ¡vel por **liberar automaticamente a memÃ³ria** ocupada por objetos que **nÃ£o sÃ£o mais utilizados** pelo programa.

ğŸ“Œ Em outras palavras:  
> O Garbage Collector remove da memÃ³ria objetos que nÃ£o possuem mais referÃªncias ativas.

Isso evita que o programador precise gerenciar memÃ³ria manualmente, como em linguagens de baixo nÃ­vel.

---

## ğŸ§  Por que o Garbage Collector Ã© importante?

Sem o Garbage Collector:
- âŒ Vazamentos de memÃ³ria seriam comuns
- âŒ O programador teria que liberar memÃ³ria manualmente
- âŒ Sistemas grandes seriam difÃ­ceis de manter

Com o Garbage Collector:
- âœ… MemÃ³ria gerenciada automaticamente
- âœ… Menos erros crÃ­ticos
- âœ… CÃ³digo mais seguro e estÃ¡vel

---

## ğŸ§± Como o Garbage Collector funciona (conceito)

O GC observa os objetos na memÃ³ria e verifica:

- Existe alguma **referÃªncia ativa** apontando para esse objeto?

Se a resposta for **nÃ£o**, o objeto se torna **elegÃ­vel para coleta**.

ğŸ“Œ Importante:
> O GC **nÃ£o remove objetos imediatamente**, apenas quando achar necessÃ¡rio.

---

## ğŸ”§ Exemplo simples de Garbage Collector

```java
Produto p1 = new Produto("TV", 1500);
Produto p2 = p1;

p1 = null;
ğŸ“Œ O objeto ainda NÃƒO Ã© coletado, pois p2 ainda aponta para ele.

ğŸ”§ Agora o objeto fica elegÃ­vel
p2 = null;
ğŸ“Œ Agora nÃ£o existe nenhuma referÃªncia apontando para o objeto.
â¡ï¸ Ele se torna elegÃ­vel para o Garbage Collector.

âš ï¸ Importante: elegÃ­vel â‰  coletado
Mesmo elegÃ­vel:

âŒ NÃ£o significa que serÃ¡ removido imediatamente

âœ… O GC decide quando liberar a memÃ³ria

ğŸ§  Escopo Local
O escopo local define onde uma variÃ¡vel existe e por quanto tempo ela vive dentro do cÃ³digo.

Em Java, variÃ¡veis locais:

Existem apenas dentro do bloco onde foram criadas

SÃ£o destruÃ­das ao sair do bloco

Podem influenciar diretamente o Garbage Collector

ğŸ”§ Exemplo de Escopo Local
public static void metodo() {
    Produto p = new Produto("Notebook", 3000);
}
ğŸ“Œ Quando o mÃ©todo termina:

A variÃ¡vel p sai do escopo

O objeto fica sem referÃªncia

Torna-se elegÃ­vel para o GC

ğŸ§  Escopo de Bloco
if (true) {
    Produto p = new Produto("Mouse", 150);
}
ğŸ“Œ Fora do if, a variÃ¡vel p nÃ£o existe mais.

ğŸ”„ RelaÃ§Ã£o entre Escopo Local e Garbage Collector
SituaÃ§Ã£o	O que acontece
VariÃ¡vel sai do escopo	ReferÃªncia Ã© perdida
Nenhuma referÃªncia aponta para o objeto	Objeto elegÃ­vel ao GC
GC roda	MemÃ³ria pode ser liberada
ğŸ“Œ Escopo controla referÃªncias, GC controla memÃ³ria.

ğŸ§ª Exemplo combinando Escopo + GC
public static void main(String[] args) {

    Produto p = new Produto("TV", 1500);

    p = new Produto("Notebook", 3000);
}
ğŸ“Œ O objeto "TV":

Perdeu a Ãºnica referÃªncia

Tornou-se elegÃ­vel para o Garbage Collector

âš ï¸ O mÃ©todo System.gc()
System.gc();
ğŸ“Œ Esse mÃ©todo:

âŒ NÃƒO garante que o GC serÃ¡ executado

âœ… Apenas sugere ao Java que execute o GC

ğŸ‘‰ NÃ£o deve ser usado como controle de memÃ³ria.

âŒ Erros comuns de iniciantes
âŒ Achar que o GC apaga objetos imediatamente

âŒ Achar que System.gc() forÃ§a a coleta

âŒ Confundir escopo com tempo de execuÃ§Ã£o

âŒ Manter referÃªncias desnecessÃ¡rias

âŒ Criar objetos sem necessidade dentro de loops
